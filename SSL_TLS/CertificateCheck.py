#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Author: Erebus
# Last update: 2021/01/27
# Tested on Kali Linux 2021

from argparse import ArgumentParser
import datetime
import hashlib
from os import listdir
from os.path import isdir, isfile, join
from OpenSSL.crypto import load_certificate, FILETYPE_PEM
import pandas as pd
from re import findall
import requests
import csv

pd.options.display.max_colwidth = 100
pd.set_option("display.max_rows", None, "display.max_columns", None)

TRUSTED_CA_URL = 'https://ccadb-public.secure.force.com/mozilla/IncludedCACertificateReportPEMCSV'
TRUSTED_CA_PATH = "/tmp/IncludedCACertificateWithPEMReport.csv"
REQUIRED_CA_CERTS = ['Amazon Root CA 1', 'Amazon Root CA 2', 'Amazon Root CA 3', 'Amazon Root CA 4',
                     'Starfield Services Root Certificate Authority - G2', 'Starfield Class 2 Certification Authority']
UNTRUSTED_CA_EXPORT_PATH = 'untrusted_CAs.csv'
files_fingerprints_dict = {}

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


# Calculate SHA-1 hash of the file
def calc_file_hash(file_path):
    BUF_SIZE = 65536
    sha1 = hashlib.sha1()

    with open(file_path, 'rb') as f:
        while True:
            data = f.read(BUF_SIZE)
            if not data:
                break
            sha1.update(data)

    return sha1.hexdigest()


# Calculate the fingerprint of the certificate
def calc_fingerprint(cert_file_string):
    try:
        cert = load_certificate(FILETYPE_PEM, cert_file_string)
        sha256_fingerprint = cert.digest("sha256").decode('utf8')
        sha256_fingerprint = sha256_fingerprint.replace(':', '')
    except:
        print(bcolors.FAIL + "INVALID certificate format detected!!!" + bcolors.ENDC)
        exit(1)
    finally:
        return sha256_fingerprint


def download_file(url, save_path):
    try:
        req = requests.get(url)
        url_content = req.content
    except requests.exceptions.RequestException as e:
        raise SystemExit(e)

    with open(save_path, 'wb') as f:
        f.write(url_content)


# Find all valid certificates in the files
def find_certs(files):
    fingerprints = []
    files_with_certs = []

    for cert_file in files:
        with open(cert_file, 'rb') as f:
            cert_list = findall(r'(-----BEGIN CERTIFICATE-----[^-]*-----END CERTIFICATE-----)', f.read().decode("utf8","ignore"))
            for cert_file_string in cert_list:
                # if the certificate is valid and its fingerprint can be calculated, append the result to the list
                temp = calc_fingerprint(cert_file_string)
                if temp is not None:
                    fingerprints.append(temp)
                    files_fingerprints_dict.setdefault(cert_file, []).append(temp)
                    if cert_file not in files_with_certs:
                        files_with_certs.append(cert_file)

    if not fingerprints:
        print(bcolors.FAIL + "There aren't any valid certificates in the assigned folder, please check and try again!" + bcolors.ENDC)
        exit(1)

    return fingerprints, files_with_certs


# Check if the CAs are not included in the CA list published by Mozilla
def find_unverified_CAs(files_fingerprints_dict, df):
    unverified_CAs = []
    unverified_CAs_dict = {}

    for cert_file, fingerprints_in_file in files_fingerprints_dict.items():
        for fingerprint in fingerprints_in_file:
            if fingerprint not in df['SHA-256 Fingerprint'].values:
                unverified_CAs.append(fingerprint)
                unverified_CAs_dict.setdefault(cert_file, []).append(fingerprint)

    return unverified_CAs, unverified_CAs_dict


def export_unverified_CAs(unverified_CAs_dict):
    df = pd.DataFrame({'Filename': unverified_CAs_dict.keys(), 'Fingerprints': unverified_CAs_dict.values()})
    df.to_csv(UNTRUSTED_CA_EXPORT_PATH, encoding='utf-8', index=False)


# List all certificate files in the target directory
def list_files(path, recursive):
    files = []

    if(isdir(path)):
        for file in listdir(path):
            low_path = join(path, file)
            if(isdir(low_path) and recursive == True):
                files += list_files(low_path, recursive)
            elif(isfile(low_path)):
                files.append(low_path)
            else:
                pass
    elif(isfile(path)):
        files.append(path)
    else:
        print(bcolors.FAIL + "No such file or directory \"%s\", please check again!" % path + bcolors.ENDC)
        exit(1)

    return files


def print_info(csv_download_time, csv_hash, files_with_certs, cert_files_hash, unverified_CAs, lack_CA_df):
    print(bcolors.BOLD + "-"*100 + bcolors.ENDC)
    print("{0:>40} {1}".format(bcolors.BOLD + "The list of trusted CAs:" + bcolors.ENDC, TRUSTED_CA_URL))
    print("{0:>40} {1}".format(bcolors.BOLD + "Downloaded at:" + bcolors.ENDC, csv_download_time))
    print("{0:>40} {1}".format(bcolors.BOLD + "SHA-1 of the list:" + bcolors.ENDC, csv_hash))
    print("{0:>40}".format(bcolors.BOLD + "The CA list(s) for examination:" + bcolors.ENDC))
    count = 0
    for cert_file, file_hash in zip(files_with_certs, cert_files_hash):
        count += 1
        print(" "*40, "{0:<10} {1}".format(bcolors.BOLD + "Filename:" + bcolors.ENDC, cert_file))
        print(" "*40, "{0:<10} {1}".format(bcolors.BOLD + "SHA-1:" + bcolors.ENDC, file_hash))
        if(len(cert_file) > 5 and count == 5):
            print(" "*40, "...")
            break
    print(bcolors.BOLD + "-"*100 + bcolors.ENDC)


def show_current_time():
    x = datetime.datetime.now()
    return x.strftime("%b %d %X %Y")


def parse_args():
    parser = ArgumentParser(description="A program that	check if the target folder contains (1) all required CA certificates (2) certificates that are not trusted by Mozilla")
    parser.add_argument('-p', '--path', dest="PATH", help='File or directory path to check for', default=".")
    parser.add_argument('-r', '--recursive', help="If this option is assigned, the program will recursively find all files under subfolders", action='store_true')
    return parser.parse_args()


def main():
    args = parse_args()

    # List the target file / all files in the target folders
    files = list_files(args.PATH, args.recursive)
    # Find all files with certificates and calculate their fingerprints
    fingerprints, files_with_certs = find_certs(files)

    # Download the trusted CA file published by Mozilla
    download_file(TRUSTED_CA_URL, TRUSTED_CA_PATH)
    # Record the download time
    csv_download_time = show_current_time()
    # Calculate hash of the downloaded file
    csv_hash = calc_file_hash(TRUSTED_CA_PATH)
    # Calculate hash of the files to be examined
    cert_files_hash = []
    for cert_file in files_with_certs:
        cert_files_hash.append(calc_file_hash(cert_file))

    # We only need the following columns
    df = pd.read_csv(TRUSTED_CA_PATH, usecols = ['Common Name or Certificate Name', 'SHA-256 Fingerprint'])
    # Create a new dataframe which only contains the required CA certificates
    required_CA_df = df.loc[df['Common Name or Certificate Name'].isin(REQUIRED_CA_CERTS)]
    # Filter out the required CA certificates that is not trusted by the DUT
    lack_CA_df = required_CA_df[~required_CA_df['SHA-256 Fingerprint'].isin(fingerprints)]
    # Filter out the CA certificates that is not included in the list published by Mozilla
    # unverified_CAs = find_unverified_CAs(fingerprints, df)
    unverified_CAs, unverified_CAs_dict = find_unverified_CAs(files_fingerprints_dict, df)
    export_unverified_CAs(unverified_CAs_dict)

    # Print out the final result
    print_info(csv_download_time, csv_hash, files_with_certs, cert_files_hash, unverified_CAs, lack_CA_df)
    if not lack_CA_df.empty:
        print("Lack of required certificate(s)," + bcolors.BOLD + bcolors.FAIL + " FAIL!!!\n" + bcolors.ENDC)
        print("The certificate(s) which should be included are listed as follows:\n")
        print(lack_CA_df.to_string(index=False) + "\n")
    else:
        print("Every required certificate is included," + bcolors.BOLD + bcolors.OKGREEN + " PASS!!!\n" + bcolors.ENDC)

    print_info(csv_download_time, csv_hash, files_with_certs, cert_files_hash, unverified_CAs, lack_CA_df)
    if unverified_CAs:
        print("Unverified certificate(s) found (not included in the CA list published by Mozilla)," + bcolors.BOLD + bcolors.FAIL + " FAIL!!!\n" + bcolors.ENDC)
        print("Fingerprint(s) of the untrusted certificate(s) are listed as follows:\n")
        for x in range(len(unverified_CAs)):
            print("{0:>5}. {1}".format(x, unverified_CAs[x]))
    else:
        print("All certificates are confirmed to be trusted," + bcolors.BOLD + bcolors.OKGREEN + " PASS!!!\n" + bcolors.ENDC)


if __name__ == "__main__":
    main()
